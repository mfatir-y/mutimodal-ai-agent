"""
Provides LLM-powered analysis of user feedback for generated code.
"""
from typing import List, Dict, Any
from collections import defaultdict

from main import query_llm

class FeedbackAnalyzer:
    """Uses LLM to analyze feedback comments and generate insights about code quality and user satisfaction."""
    
    def __init__(self, model: str = "mistral"):
        self.model = model

    def analyze_feedback(self, feedback_entries: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Analyze a collection of feedback entries to generate insights.
        Args: feedback_entries: List of feedback entries from FeedbackManager
        Returns: Dict containing various analysis results
        """
        if not feedback_entries:
            return {"error": "No feedback entries to analyze"}
            
        prompt = "Analyze the following feedbacks to provide insights and/or summary about the code quality and user satisfaction to the users.\n"
        i = 1
        for entry in feedback_entries:
            if entry.get('comment'):
                prompt += (f"- User Prompt {i}: {entry.get('prompt')}, Response Generated: {entry.get('code_description')}, "
                f"Code Generated: {entry.get('code')}, Rating: {entry.get('rating')}, Comment: {entry.get('comment')}, "
                f"Models Used: {entry.get('code_model')}, {entry.get('chat_model')}\n")
                i += 1
        prompt += "Return a json object with only the following keys: 'common_themes', 'areas_for_improvement', 'what_users_like', 'suggestions'"
        return query_llm(prompt, self.model)

    def generate_improvement_suggestions(self, code: str, code_description: str, feedback: str, prompt: str = "") -> Dict[str, Any]:
        """
        Generate specific suggestions for improving code based on feedback.
        Args: code: The generated code
              feedback: User feedback about the code
              prompt: The original prompt that generated the code
        Returns: Dict containing categorized improvement suggestions
        """
        full_prompt = (f"Analyze the response from LLM and the feedback given by the user:\n"
                      f"PROMPT GIVEN BY USER:\n"
                      f"{prompt or 'Not provided'}\n"
                      f"RESPONSE GENERATED BY LLM:\n"
                      f"{code_description or 'Not provided'}\n"
                      f"CODE GENERATED BY LLM:\n"
                      f"{code or 'Not provided'}\n"
                      f"FEEDBACK GIVEN ON THE RESPONSE:\n"
                      f"{feedback or 'Not provided'}\n"
                      f"Provide an improved response based on the prompt and feedback. Return a json object with only the keys 'suggestions'")
        return query_llm(full_prompt, self.model)

    def categorize_feedback(self, feedback_entries: List[Dict[str, Any]]) -> Dict[str, List[str]]:
        """
        Categorize feedback comments into themes.        
        Args: feedback_entries: List of feedback entries
        Returns: Dict mapping categories to lists of feedback
        """
        categories = defaultdict(list)
        
        for entry in feedback_entries:
            if not entry.get('comment'):
                categories["Feedbacks Missing"].append({
                    'code_id': entry['code_id'],
                    'rating': entry['rating'],
                    'timestamp': entry['timestamp'][4:16]
                })
                continue
                
            prompt = (f"Categorize this feedback into one of the following categories [Code Quality, Performance, Readability, Documentation, Functionality, Best Practices]\n"
                      f"FEEDBACK ON RESPONSE: {entry['comment']} ,RESPONSE: {entry.get('code', 'Not provided')} ,PROMPT GIVEN: {entry.get('prompt', 'Not provided')} \n"
                      "Return only one category name as a list.")
            result = query_llm(prompt, self.model)
            if isinstance(result, list):
                for category in result:
                    categories[category].append({
                        'code_id': entry['code_id'],
                        'comment': entry['comment'],
                        'rating': entry['rating'],
                        'timestamp': entry['timestamp'][:16]
                    })
            else:
                categories["Uncategorized"].append({
                    'code_id': entry['code_id'],
                    'comment': entry['comment'],
                    'rating': entry['rating'],
                    'timestamp': entry['timestamp'][:16]
                })
                
        return dict(categories)
